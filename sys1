#include <iostream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <fstream>

//c++ program to calculate simple poisson eqn in xy coords

int main()
{
  using namespace std;

  ofstream outf1("sys1.dat");

cout << "Enter the radius of the outer circle: "; 
 double rv = 0;
 cin >> rv;
 
cout << "Enter the radius of the inner circle: "; 
  double rg = 0;
 cin >> rg;

cout << "Enter the voltage of the outer circle: "; 
  int v0 = 0;
 cin >> v0;


 double dx=1.0; //grid spacing
 double dy=1.0; //grid spacing

 int xstep= (2*rv/dx)+1;
 int ystep = (2*rv/dy)+1;

 //this section used for a set number of iterations
 // int tstep = 5; //number of iterations

 //this
 double error = 0.0001; //when points stop changing more than this, stop iteration
 int errorcount=0;

 double u[xstep][ystep]; //multidimensional array, value of previous iterations
 double unew[xstep][ystep]; // value of current iterations

 //boundary conditions 
 for (int j=0; j<(xstep); j++){
   for (int k=0; k<(ystep);k++){

       if ( j==0 || j==xstep || k==0 || k==ystep )
       u[j][k]=v0;
       else
	 u[j][k]=0;
   }
 }
 
 while(errorcount < xstep-1){ //while there are points that do not contribute to error count, iterations continue, when all points change less than error, iteration stops
  
   errorcount=0; //reset error count

 for (int j=1; j<(xstep); j++){
   for (int k=1;k<(ystep);k++){
     
     //if array point larger than radius of outer circle it equals zero 
 if ((pow((k-ceil((xstep)/2)),2) + pow((j-ceil((ystep)/2)),2))>= pow(rv,2)) 
       unew[j][k]=v0; 
       
       //if array point smaller than radius of ground circle it equals v+ 
  else if ((pow((k-ceil((xstep)/2)),2) + pow((j-ceil((ystep)/2)),2))<= pow(rg,2)) 
       unew[j][k]=0;           
     else unew[j][k]=(0.25)*(u[j-1][k] + u[j+1][k] + u[j][k-1] + u[j][k+1]);
 }
 } 



 //section that calculates number of points that have cahnged by less than (error)
for(int j=0; j<xstep; j++){
 //if point on arbituary line has changed less than error, it gets added to error count
   if ( abs(u[j][ystep/2] - unew[j][ystep/2]) < error)
   errorcount+=1;}


 //reset boundary conditions
for (int j=0; j<(xstep); j++){
   for (int k=0;k<(ystep);k++){

     if ( j==0 || j==xstep || k==0 || k==ystep )
       u[j][k]=v0;
     else
       u[j][k]=unew[j][k]; 
 }
 }
 

 

 }

 //print values to data file
  for ( int j = 0; j < xstep; j++ ) {
   for ( int k = 0; k < ystep; k++ ) {
    
     outf1<<j<<" "<<k<<" "<<u[j][k] <<endl;  
   }
   }
outf1.close();

 ofstream outf2("sys1vector.dat");

 for ( int j = 1; j < xstep-1; j++ ) {
   for ( int k = 1; k < ystep-1; k++ ) {
    
     outf2<<j<<" "<<k<<" "<<((u[j-1][k]-u[j+1][k])/(2*dx))<< " " << ((u[j][k-1]-u[j][k+1])/(2*dy))  <<endl;  
   }
   }
 outf2.close();
    return 0;
}
